package music;/** * The Functional Music project *  * Abstract super class to cover all of the musical stuff in the project: *  * Notes: Represented within our language as the note name (such as C or E)  * followed by 's' or 'f' (if sharp or flat) then the octave number (Cs6, Bf2,  * etc.) Notes are single atomic elements that contains 5 variables for keeping  * track of pitch, velocity(volume), length, instrument and absolute position in * the piece (absolute). *  * After: Represented within our language as '&', this connects two pieces of  * music together sequentially. *  * Together: Represented as '!', this connects two pieces of music to be played * simultaneously. *  * Mod: Represented by the built-in functions(up(), down(), bagpipe()), these  * are contained in the environment, this contains a Modifier and a piece of  * music to apply to it. * @author Western State College, CIS412 class */public abstract class Music {    //constant to multiply every number by to get the midi timestamp    public static final double timeSignature = 2000;    public static Music up(Music music, double n) {        Modifier modifier = new Modifier();        modifier.pitchOffset = (int) n;        MusMod mod = new MusMod(music, modifier);        return mod;    }    public static Music down(Music music, double n) {        Modifier modifier = new Modifier();        modifier.pitchOffset = (int) -n;        MusMod mod = new MusMod(music, modifier);        return mod;    }    public static Music withInstrument(Music music, String n) {        Modifier modifier = new Modifier();        modifier.instrumentChange = n;        MusMod mod = new MusMod(music, modifier);        return mod;    }    public static Music withPitch(Music music, double n) {        Modifier modifier = new Modifier();        modifier.pitchOverride = (int) n;        MusMod mod = new MusMod(music, modifier);        return mod;    }    //play at this volume    public static Music withVelocity(Music music, double n) {        Modifier modifier = new Modifier();        modifier.velocityOverride = (int) n;        MusMod mod = new MusMod(music, modifier);        return mod;    }    // use to change current volume    // ex: play twice as loud ( louder -softer)    public static Music changeVelocity(Music music, double n) {        Modifier modifier = new Modifier();        modifier.velocityMultiplier = n;        MusMod mod = new MusMod(music, modifier);        return mod;    }    public static Music changeDuration(Music music, double n) {        Modifier modifier = new Modifier();        modifier.durationMultiplier = n;        MusMod mod = new MusMod(music, modifier);        return mod;    }    /**     * Example of a Factory Method approach to the note creation.     * @param noteName     * @param duration     * @param velocity     * @param instrument     * @return     */    public static MusNote note(String noteName, double duration, double velocity, String instrument) {        char[] parsedName = noteName.toCharArray();        int tempPitch = 0;        if (parsedName[0] == 'c') {            tempPitch = 1;        } else if (parsedName[0] == 'd') {            tempPitch = 3;        } else if (parsedName[0] == 'e') {            tempPitch = 5;        } else if (parsedName[0] == 'f') {            tempPitch = 6;        } else if (parsedName[0] == 'g') {            tempPitch = 8;        } else if (parsedName[0] == 'a') {            tempPitch = 10;        } else if (parsedName[0] == 'b') {            tempPitch = 12;        } else {            return null;//impossible        }        if (parsedName.length > 2) {            if (parsedName[1] == 's') {                tempPitch++;            } else if (parsedName[1] == 'f') {                tempPitch--;            }            tempPitch += 12 * (Character.getNumericValue(parsedName[2]) - 1);        } else {            tempPitch += 12 * (Character.getNumericValue(parsedName[1]) - 1);        }        if (tempPitch <= -1) {            throw new ExecutionError("Error:" + noteName + " cannot be parsed into a note!");        }        MusNote result = new MusNote(tempPitch, duration, (int) velocity, instrument);        return result;    }    public boolean isNote() {        return false;    }    public boolean isAfter() {        return false;    }    public boolean isTogether() {        return false;    }    public boolean isMod() {        return false;    }    public abstract Performance perform(double time, Modifier modifier);    public abstract String toString();    public abstract String prettyPrint();}
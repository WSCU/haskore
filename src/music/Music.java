package music;import java.util.ArrayList;import java.util.logging.Level;import java.util.logging.Logger;import javax.sound.midi.Instrument;import javax.sound.midi.MidiSystem;import javax.sound.midi.MidiUnavailableException;import javax.sound.midi.Synthesizer;/** * The Functional Music project *  * Abstract super class to cover all of the musical stuff in the project: *  * Notes: Represented within our language as the note name (such as C or E)  * followed by 's' or 'f' (if sharp or flat) then the octave number (Cs6, Bf2,  * etc.) Notes are single atomic elements that contains 5 variables for keeping  * track of pitch, velocity(volume), length, instrument and absolute position in * the piece (absolute). *  * After: Represented within our language as '&', this connects two pieces of  * music together sequentially. *  * Together: Represented as '!', this connects two pieces of music to be played * simultaneously. *  * Mod: Represented by the built-in functions(up(), down(), bagpipe()), these  * are contained in the environment, this contains a Modifier and a piece of  * music to apply to it. * @author Western State College, CIS412 class */public abstract class Music {    //constant to multiply every number by to get the midi timestamp    public static String[] instrumentNames = {"Acoustic Grand Piano", "Harpsichord", "Vibraphone", "Reed Organ", "Acoustic Guitar (nylon)", "Overdriven Guitar", "Acoustic Bass", "Violin", "Viola", "Cello", "Trumpet", "Trombone", "French Horn", "Tenor Sax", "Oboe", "Bassoon", "Clarinet", "Flute", "Pan Flute", "Kalimba", "Woodblock"};    public static final BigRational timeSignature = new BigRational("2000");    private static String getInstr(int in)    {        try {            Synthesizer synth = MidiSystem.getSynthesizer();            Instrument[] avail = synth.getAvailableInstruments();            Instrument i = avail[in];                        System.out.println("MUSIC-getTnstr: "+i.getName());            return i.getName();        } catch (MidiUnavailableException ex) {            System.out.println("MIDI ERROR:MUSIC-getTnstr"+ex.getMessage());            return null;        }    }    /**     * Raises the pitch of the Music by the designated double number     * @param music assigns the Music to modify     * @param n assigns the amount to raise the pitch     * @return returns the end modification     */    public static Music up(Music music, int n) {        Modifier modifier = new Modifier();        modifier.pitchOffset = n;        MusMod mod = new MusMod(music, modifier);        return mod;    }    /**     * Lowers the pitch by the designated double number     * @param music assigns the Music to modify     * @param n assign the number to lower the pitch by     * @return returns the end modification     */    public static Music down(Music music, int n) {        Modifier modifier = new Modifier();        modifier.pitchOffset = -n;        MusMod mod = new MusMod(music, modifier);        return mod;    }    /**     * sets the instrument being used to make Music     * @param music assigns which Music to modify     * @param n assigns the instrument to change to     * @return returns the end modification     */    public static Music withInstrument(Music music, int n) {        Modifier modifier = new Modifier();        modifier.instrumentChange = getInstr(n);        MusMod mod = new MusMod(music, modifier);        return mod;    }    /**     * sets the initial pitch of the given Music to the designated number     * @param music assigns the Music to be modified     * @param n assigns the number to change the pitch to     * @return returns the end modification     */    public static Music withPitch(Music music, int n) {        Modifier modifier = new Modifier();        modifier.pitchOverride = n;        MusMod mod = new MusMod(music, modifier);        return mod;    }    //play at this volume    /**     * sets the initial volume of the given Music to the designated volume     * @param music assigns the Music to be modified     * @param n assigns the number to change the volume to     * @return returns the end modification     */    public static Music withVelocity(Music music, int n) {        Modifier modifier = new Modifier();        modifier.velocityOverride = n;        MusMod mod = new MusMod(music, modifier);        return mod;    }    // use to change current volume    // ex: play twice as loud ( louder -softer)    /**     * changes the volume of the given Music to the designated volume     * @param music assigns the Music to be modified     * @param n assigns the number to change the volume to     * @return returns the end modification     */    public static Music changeVelocity(Music music, int n) {        Modifier modifier = new Modifier();        modifier.velocityMultiplier = n;        MusMod mod = new MusMod(music, modifier);        return mod;    }    /**     * changes the duration of the given Music to the designated duration     * @param music assigns the Music to be modified     * @param n assigns the new length of the Music     * @return returns the end modification     */    public static Music changeDuration(Music music, BigRational n) {        Modifier modifier = new Modifier();        modifier.durationMultiplier = n;        MusMod mod = new MusMod(music, modifier);        return mod;    }    /**     * Example of a Factory Method approach to the note creation.     * @param noteName     * @param duration     * @param velocity     * @param instrument     * @return     */    public static MusNote note(String noteName, BigRational duration, int velocity, String instrument) {        char[] parsedName = noteName.toCharArray();        int tempPitch = 0;        if (noteName.equals("r")) {            tempPitch = 0;            velocity = 0;        } else {            if (parsedName[0] == 'c') {                tempPitch = 1;            } else if (parsedName[0] == 'd') {                tempPitch = 3;            } else if (parsedName[0] == 'e') {                tempPitch = 5;            } else if (parsedName[0] == 'f') {                tempPitch = 6;            } else if (parsedName[0] == 'g') {                tempPitch = 8;            } else if (parsedName[0] == 'a') {                tempPitch = 10;            } else if (parsedName[0] == 'b') {                tempPitch = 12;            } else {                return null;//impossible            }            if (parsedName.length > 2) {                if (parsedName[2] == 's') {                    tempPitch++;                } else if (parsedName[2] == 'f') {                    tempPitch--;                }                tempPitch += 24 * (Character.getNumericValue(parsedName[1]) - 1);            } else {                tempPitch += 24 * (Character.getNumericValue(parsedName[1]) - 1);            }        }        if (tempPitch <= -1) {            throw new ExecutionError("Error:" + noteName + " cannot be parsed into a note!");        }        //System.out.println("MUSIC NOTE "+tempPitch+" "+velocity+" "+instrument+" "+duration);        MusNote result = new MusNote(tempPitch, velocity, instrument, duration);        return result;    }    public static MusNote rest(BigRational d)    {       return Music.note("r",d , 0, "Piano");    }    public static BigRational duration(Music m)    {        return m.dur();    }    public static Music reverse(Music m)    {               Modifier mod = new Modifier();        Music r = m.rev();        return r;    }    public abstract BigRational perform(BigRational time, Modifier modifier, ArrayList<MusNote> notes);    public abstract Music rev();    public abstract BigRational dur();    public abstract String toString();    public abstract String prettyPrint();}